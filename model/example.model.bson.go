// Code generated by gg; DO NOT EDIT.
// gg version: 0.0.1
// generate time: 2024-04-01 18:01:11
// src code version:
// src code commit time :
package model

import "go.mongodb.org/mongo-driver/bson"

import (
	"gen_tools/model/mdata"
)

func (s *TestA) MarshalBSON() ([]byte, error) {
	var doc = bson.M{"_id": s.id, "a": s.a, "b": s.b}
	return bson.Marshal(doc)
}
func (s *TestA) UnmarshalBSON(data []byte) error {
	doc := struct {
		Id uint64 `bson:"_id"`
		A  int64  `bson:"a"`
		B  int32  `bson:"b"`
	}{}
	if err := bson.Unmarshal(data, &doc); err != nil {
		return err
	}
	s.SetId(doc.Id)
	s.SetA(doc.A)
	s.SetB(doc.B)
	return nil
}
func (s *TestA) BuildDirty(m bson.M, preKey string) {
	dirty := s.GetDirty()
	if dirty == 0 {
		return
	}
	if dirty&(1<<0) != 0 {
		mdata.AddSetDirtyM(m, mdata.MakeBsonKey("_id", preKey), s.id)
	}
	if dirty&(1<<1) != 0 {
		mdata.AddSetDirtyM(m, mdata.MakeBsonKey("a", preKey), s.a)
	}
	if dirty&(1<<2) != 0 {
		mdata.AddSetDirtyM(m, mdata.MakeBsonKey("b", preKey), s.b)
	}
	return
}
func (s *TestA) CleanDirty(withChildren bool) {
	s.DirtyModel.CleanDirty(withChildren)
	if withChildren {
	}
}
func (s *TestB) MarshalBSON() ([]byte, error) {
	var doc = bson.M{"_id": s.id, "m": s.m, "n": s.n, "c": s.c, "d": s.d}
	return bson.Marshal(doc)
}
func (s *TestB) UnmarshalBSON(data []byte) error {
	doc := struct {
		Id uint64                      `bson:"_id"`
		M  string                      `bson:"m"`
		N  *TestA                      `bson:"n"`
		C  *mdata.MList[*TestA]        `bson:"c"`
		D  *mdata.MMap[string, *TestA] `bson:"d"`
	}{}
	if err := bson.Unmarshal(data, &doc); err != nil {
		return err
	}
	s.SetId(doc.Id)
	s.SetM(doc.M)
	s.SetN(doc.N)
	s.SetC(doc.C)
	s.SetD(doc.D)
	return nil
}
func (s *TestB) BuildDirty(m bson.M, preKey string) {
	dirty := s.GetDirty()
	if dirty == 0 {
		return
	}
	if dirty&(1<<0) != 0 {
		mdata.AddSetDirtyM(m, mdata.MakeBsonKey("_id", preKey), s.id)
	}
	if dirty&(1<<1) != 0 {
		mdata.AddSetDirtyM(m, mdata.MakeBsonKey("m", preKey), s.m)
	}
	if dirty&(1<<2) != 0 {
		if s.n == nil {
			mdata.AddUnsetDirtyM(m, mdata.MakeBsonKey("n", preKey))
		} else {
			s.n.BuildDirty(m, mdata.MakeBsonKey("n", preKey))
		}
	}
	if dirty&(1<<3) != 0 {
		if s.c == nil {
			mdata.AddUnsetDirtyM(m, mdata.MakeBsonKey("c", preKey))
		} else {
			s.c.BuildDirty(m, mdata.MakeBsonKey("c", preKey))
		}
	}
	if dirty&(1<<4) != 0 {
		if s.d == nil {
			mdata.AddUnsetDirtyM(m, mdata.MakeBsonKey("d", preKey))
		} else {
			s.d.BuildDirty(m, mdata.MakeBsonKey("d", preKey))
		}
	}
	return
}
func (s *TestB) CleanDirty(withChildren bool) {
	s.DirtyModel.CleanDirty(withChildren)
	if withChildren {
		if s.n == nil {
			s.n.CleanDirty(withChildren)
		}
		if s.c == nil {
			s.c.CleanDirty(withChildren)
		}
		if s.d == nil {
			s.d.CleanDirty(withChildren)
		}
	}
}
func (s *TestC) MarshalBSON() ([]byte, error) {
	var doc = bson.M{"_id": s.id, "x": s.x, "y": s.y}
	return bson.Marshal(doc)
}
func (s *TestC) UnmarshalBSON(data []byte) error {
	doc := struct {
		Id uint64 `bson:"_id"`
		X  string `bson:"x"`
		Y  *TestB `bson:"y"`
	}{}
	if err := bson.Unmarshal(data, &doc); err != nil {
		return err
	}
	s.SetId(doc.Id)
	s.SetX(doc.X)
	s.SetY(doc.Y)
	return nil
}
func (s *TestC) BuildDirty(m bson.M, preKey string) {
	dirty := s.GetDirty()
	if dirty == 0 {
		return
	}
	if dirty&(1<<0) != 0 {
		mdata.AddSetDirtyM(m, mdata.MakeBsonKey("_id", preKey), s.id)
	}
	if dirty&(1<<1) != 0 {
		mdata.AddSetDirtyM(m, mdata.MakeBsonKey("x", preKey), s.x)
	}
	if dirty&(1<<2) != 0 {
		if s.y == nil {
			mdata.AddUnsetDirtyM(m, mdata.MakeBsonKey("y", preKey))
		} else {
			s.y.BuildDirty(m, mdata.MakeBsonKey("y", preKey))
		}
	}
	return
}
func (s *TestC) CleanDirty(withChildren bool) {
	s.DirtyModel.CleanDirty(withChildren)
	if withChildren {
		if s.y == nil {
			s.y.CleanDirty(withChildren)
		}
	}
}
